import os
import re
import subprocess
import time


def strip_ansi(text):
    ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
    return ansi_escape.sub("", text)


def run_python(day_dir):
    try:
        # Run using the same python interpreter
        result = subprocess.run(
            ["python", "solution.py"],
            cwd=day_dir,
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            return None

        output = result.stdout
        # Parse lines like [part_1] Time: 0.1234 ms
        times = []
        for line in output.splitlines():
            if "Time:" in line:
                parts = line.split("Time:")[1].strip().split()
                if len(parts) >= 2:
                    val = float(parts[0])
                    unit = parts[1]
                    if unit == "us":
                        val /= 1000.0
                    elif unit == "s":
                        val *= 1000.0
                    times.append(val)

        return sum(times) if times else None
    except Exception as e:
        print(f"Error running Python for {day_dir}: {e}")
        return None


def run_rust(year_dir, day_name):
    try:
        # cargo run --release -p dayXX
        result = subprocess.run(
            ["cargo", "run", "--release", "-p", day_name],
            cwd=year_dir,
            capture_output=True,
            text=True,
            timeout=30,  # Compilation might take time
        )
        if result.returncode != 0:
            # Maybe it didn't compile or threw error
            return None

        output = result.stdout
        # Parse lines like [Part 1] Time: 123.45¬µs or 45ms or 1.2s
        # Rust Debug format is variable.
        # We need a regex for standard Duration debug output roughly.
        # It usually looks like "123.45¬µs", "42ms", "1.2s"

        total_ms = 0.0
        found = False

        # Regex to capture value and unit
        # Matches: 123.45ms, 123ns, 12s, 500¬µs
        regex = re.compile(r"Time: ([0-9.]+)(\w+|¬µs)")

        for line in output.splitlines():
            line = strip_ansi(line)  # Cargo might output color
            match = regex.search(line)
            if match:
                found = True
                val = float(match.group(1))
                unit = match.group(2)

                if unit == "¬µs" or unit == "us":
                    val /= 1000.0
                elif unit == "ns":
                    val /= 1000000.0
                elif unit == "s":
                    val *= 1000.0
                # ms is 1.0
                total_ms += val

        return total_ms if found else None

    except Exception as e:
        print(f"Error running Rust for {day_name}: {e}")
        return None


def format_time(ms):
    if ms is None:
        return "N/A"
    if ms < 1:
        return f"{ms*1000:.0f}¬µs"
    if ms >= 1000:
        return f"{ms/1000:.2f}s"
    return f"{ms:.2f}ms"


def update_readme():
    base_dir = os.path.dirname(os.path.abspath(__file__))
    readme_path = os.path.join(os.path.dirname(base_dir), "README.md")

    with open(readme_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Regex to find the table row
    # | 01 | [Title](...) | [üêç Solution](...) | [ü¶Ä Solution](...) |
    # We want to replace the Solution links to include the badge/text
    # But checking if they already have runs might be tricky.
    # Let's assume standard format generated by my previous setup.

    days_dir = os.path.join(base_dir, "days")

    for item in os.listdir(days_dir):
        if not item.startswith("day"):
            continue

        day_num_str = item.replace("day", "")
        if not day_num_str.isdigit():
            continue

        day_num = int(day_num_str)
        # Format 01, 02...
        day_id = f"{day_num:02d}"

        print(f"Benchmarking Day {day_id}...")

        # Python
        py_ms = run_python(os.path.join(days_dir, item))
        py_text = format_time(py_ms)
        print(f"  Python: {py_text}")

        # Rust
        rs_ms = run_rust(base_dir, item)  # item is 'day01' which matches package name
        rs_text = format_time(rs_ms)
        print(f"  Rust:   {rs_text}")

        # Update README line match
        # Look for line starting with | day_id |
        # Regex: (| \s* 01 \s* | .*? |) (.*?) (|) (.*?) (|)
        # It's fragile to parse markdown with regex, but for a known table it's okay.

        # Strategy: Find the line. Split by |. Update col 3 and 4. Join.

        lines = content.splitlines()
        new_lines = []
        for line in lines:
            if line.strip().startswith(f"| {day_id} |"):
                parts = [p.strip() for p in line.strip().split("|")]
                # parts[0] is empty (before first |)
                # parts[1] is Day
                # parts[2] is Title
                # parts[3] is Python
                # parts[4] is Rust
                # parts[5] is empty (after last |)

                if len(parts) >= 6:
                    # Update Python Col
                    # Keep the link part [üêç Solution](...) and replace anything after it
                    py_link_match = re.match(r"(\[.*?\]\(.*?\))", parts[3])
                    if py_link_match:
                        parts[3] = f"{py_link_match.group(1)} <br> ‚ö° {py_text}"

                    # Update Rust Col
                    rs_link_match = re.match(r"(\[.*?\]\(.*?\))", parts[4])
                    if rs_link_match:
                        parts[4] = f"{rs_link_match.group(1)} <br> ‚ö° {rs_text}"

                    # Reconstruct
                    new_line = f"| {parts[1]} | {parts[2]} | {parts[3]} | {parts[4]} |"
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        content = "\n".join(new_lines)

    with open(readme_path, "w", encoding="utf-8") as f:
        f.write(content)

    print("README updated successfully!")


if __name__ == "__main__":
    update_readme()
